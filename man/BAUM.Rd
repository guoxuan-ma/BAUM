% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BAUM.R
\name{BAUM}
\alias{BAUM}
\title{BAUM}
\usage{
BAUM(
  r,
  Q,
  g,
  num_samples = 5000,
  m0 = 0,
  G = 50,
  mu_1 = 1:50,
  a_1 = 10000,
  a_2 = 1000,
  a_3 = 2000,
  a_4 = 1000,
  a_5 = 50,
  b_1 = 1,
  b_3 = 1000,
  b_4 = 1,
  b_5 = 50,
  a_g = rep(10, 50),
  b_g = rep(10, 50),
  pi = c(0.5, 0.5),
  rho = c(0.1, 0.1)
)
}
\arguments{
\item{r}{a vector of length p containing feature-specific test statistics}

\item{Q}{a p times k matrix of matching uncertainty prior information}

\item{g}{an igraph object of network}

\item{num_samples}{a positive integer, number of MCMC samples}

\item{m0}{an integer, mean for the null component}

\item{G}{a positive integer, number of clusters for the approximation of Dirichlet process mixture (DPM) of the alternative component}

\item{mu_1}{a vector of length G, the prior means of Gaussian distribution in G clusters for the approximation of DPM, i.e., m_g for g = 1, ..., G}

\item{a_1}{a number, shape of the Inverse Gamma prior for gamma_0}

\item{a_2}{a number, shape of the Inverse Gamma prior for gamma_g}

\item{a_3}{a number, shape of the Inverse Gamma prior for sigma^2}

\item{a_4}{a number, shape of the Gamma prior for beta_g, i.e., the scale (rate of Gamma) for gamma_g}

\item{a_5}{a number, shape of the Inverse Gamma prior for sigma^2_g, i.e., the variance of m_g}

\item{b_1}{a number, rate of the Inverse Gamma prior for gamma_0}

\item{b_3}{a number, rate of the Inverse Gamma prior for sigma^2}

\item{b_4}{a number, rate of the Gamma prior for beta_g, i.e., the scale (rate of Gamma) for gamma_g}

\item{b_5}{a number, rate of the Inverse Gamma prior for sigma^2_g, i.e., the variance of m_g}

\item{a_g}{a vector of length G, Beta prior parameter for p_g for g = 1, .., G}

\item{b_g}{a vector of length G, Beta prior parameter for p_g for g = 1, .., G}

\item{pi}{a vector of length 2, prior label distribution; the two elements should be between 0 and 1, and sum up to 1}

\item{rho}{a vector of 2 positive numbers, global neighborhood parameters}
}
\value{
para_sample, a list of MCMC samples for each parameter, including m_1, beta, gamma_0, gamma_1, sigma_sq, sigma_sq_K, eta_0, eta_1, Lambda, z, N_g and K.
}
\description{
function for Bayesian Analysis for Untargeted Metabolomics data (BAUM)
}
\examples{
# this is a toy example to illustrate how to use the BAUM package
# data is available under the same folder
# metabolites network, features, and potential matchings are a part of the
# covid-19 metabolomics data
# code and data for this example can be found under the example folder on the github page https://github.com/guoxuan-ma/BAUM

# for details, please look at our paper:
# Guoxuan Ma, Jian Kang and Tianwei Yu. (2023+). Bayesian Functional Analysis for Untargeted Metabolomics Data with Matching Uncertainty and Very Small Sample Sizes

# install package from github
devtools::install_github("guoxuan-ma/BAUM")

# loading libraries
library(BAUM)
library(igraph)
library(Matrix)

# load data
load("toy_example.Rdata")

# Suppose there are p features and k metabolites. Data should include:
# 1. r: the feature-specific summary statistics, should be a vector of length p and can be obtained by statistical tests of user's choice
# 2. feature_meta: a binary matrix of dimension p times k, it specifies whether a feature is potentially matched to a metabolite
# 3. g: the metabolite network with k vertices

# we construct matrix Q, the prior matching confidence
# here we assume feature-metabolite has equal matching confidence, which is for illustration but not necessary
Q = feature_meta / rowSums(feature_meta)

# run BAUM for 1000 MCMC steps
set.seed(2023)
para_samples = BAUM(r, Q, g, num_samples = 1000)

# first 500 steps for burn-in
begin = 501
end = 1000

# FDR threshold at alpha = 0.2 on metabolites posterior inclusion probability
FDR_threshold(para_samples$z[begin:end, ], 0.2)

# metabolites fdr
fdr = p2fdr(para_samples$z[begin:end, ])

# prediction on z: whether or not a metabolite is significant
pred_z = (colMeans(para_samples$z[begin:end, ]) >= FDR_threshold(para_samples$z[begin:end, ], 0.2)) + 0

# plot network structure
coords = layout_(g, nicely())
plot(g,
     layout = coords,
     vertex.color = "palegreen3",
     vertex.size = 5,
     vertex.label = NA,
     vertex.frame.color = "white",
     edge.width = 0.5)

# plot prediction results
plot(g,
     layout = coords,
     vertex.color = c("palegreen3", "salmon")[pred_z + 1],
     vertex.size = 5,
     vertex.label = NA,
     vertex.frame.color = "white",
    edge.width = 0.5)

# matching uncertainty estimation
p = dim(Q)[1]
k = dim(Q)[2]
pred_Lambda = matrix(0, nrow = p, ncol = k)
pred_r_vec = matrix(0, nrow = end - begin + 1, ncol = p)
for (s in begin:end) {
  pred_Lambda = pred_Lambda + para_samples$Lambda[[s]] / (end - begin + 1)
  pred_r_vec[s-begin+1, ] = as.vector(para_samples$Lambda[[s]] \%*\% ifelse(para_samples$z[s, ],
                                                                          para_samples$eta_1[s, ],
                                                                          para_samples$eta_0[s]))
}
pred_Lambda = as.matrix(pred_Lambda)

}
